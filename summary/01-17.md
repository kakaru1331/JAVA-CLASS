# 01-17

# 수업 정리

## lambda expression
람다식은 익명 함수를 생성하기 위한 식이다.    
함수형 프로그래밍의 향기가 살짝 나는 부분인데,   
람다의 사용이 코드의 간결성을 높여준다는 의의가 있다.   

**람다 사용법**    
~~~
(a) -> { System.out.println(a); }
~~~

~~~
a -> System.out.println(a);
~~~

~~~
() -> { return; }
~~~

~~~
(x, y) -> x + y
~~~

### 클래스 멤버와 로컬 변수 사용
람다식 블록 내에서 클래스 멤버와 로컬 변수를 사용할 수 있다.    
다만 로컬 변수의 사용에는 제약이 있다.    

**람다의 this**    
람다식 내부의 this는 실행한 객체를 참조한다.    
내부의 익명 객체가 아니라!   
바깥 객체를 참조하려면 className.this를 이용하자.    

**람다의 매개 변수와 로컬 변수**   
람다식에서 메소드 매개 변수와 로컬 변수는 final로 써야만 한다.    
다시 말해 읽는 것은 허용되지만, 람다 내외부에서 변경할 수는 없다.    

---

## Collection Framework
복수개의 데이터를 저장하려면 어떻게 해야할까?   
배열을 만들면 간단히 해결된다.   
그런데 배열은 선언된 크기 이상 자료를 담을 수 없다.    
값을 지우고 수정하는 건 어떠한가?      
게다가 그러한 경우가 많다면?    
**아찔하다.**    
배열 말고 다른 자료구조를 써보자.   
자료구조를 구현해야 하는 걱정은 하지 않아도 된다.   
자바가 괜찮은 것들을 제공하니까.    

### List
list는 객체를 일렬로 저장하는 구조다.   
저장 시에 자동으로 인덱스가 부여되고,   
인덱스를 이용해서 검색과 삭제가 가능하다.   
동일한 객체를 저장할 수 있다.    
null 값을 저장할 수 있다.     
null 값이 들어있다면 해당 인덱스는 참조하지 않는다.   

**Vector**    
vector는 ArrayList와 동일한 내부 구조를 가지고 있다.   
차이점은 vector는 동기화된 메소드이기 때문에 스레드 세이프하다.   

**LinkedList**    
LinkedList는 인접 객체를 참조하는 방식으로 관리한다.    

끝에 데이터를 수정하는 경우, ArrayList의 성능이 좀 더 좋다.   
그러나 중간의 값을 수정할 경우 인덱스를 다 밀어줘야 한다.   
이에 비해 LinkedList는 앞뒤 객체의 참조만 바꿔주기만 하면 된다.   
경우에 따라서 잘 골라서 써야하겠다.    

### Set
Set은 배열과 달리 순서가 보장되지 않는다. 또한 중복 저장이 불가능하다.    
순서가 보장되지 않기 때문에 자연스레 인덱스가 없다.    

### Map
Map은 Key와 Value를 포함한 Entry 객체이다.    
key와 value 모두 객체이다.   
key는 중복될 수 없다. 중복 key를 저장하면 value가 대체된다.    

### Binary Tree
이진 트리는 다수의 노드가 트리 형태로 연결된 구조다.    
최상위의 루트 노드로 시작해서 부모와 자식 관계가 가지처럼 계속 뻗어나간다.    
요컨대 프랙탈 구조다.    
부모 노드보다 작으면 왼쪽, 크면 오른쪽에 저장된다.   

### LIFO & FIFO
LIFO를 제공하는 Stack 클래스    
FIFO를 제공하는 Queue 인터페이스    

**Stack**   
스택은 동전탑과 비슷하다.   
마지막에 올린 동전이먼저 나가고,    
처음에 쌓인 동전이 마지막에 나간다.    

**Queue**   
큐는 스택과 정반대다.    
일찍 들어오면 일찍 나간다.   

---

# 더 알아볼 것
- 수학
- HW
 