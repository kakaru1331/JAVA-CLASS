# 01-12

## 복습

**객체지향**    
객체를 속성과 기능을 구분하여 모델을 만든다.   
모델링을 통하여 만든 하나의 집합을 부품 단위로 쪼갠다.   
부품 단위로 설계 후 조립하는 것.   
이것이 객체지향 기법이다.    

**Encapsulation**   
객체의 필드와 메소드를 외부에 노출하지 않을 수 있다.    
여기서 얻을 수 있는 이점은 내부 구조의 은닉이다.    
외부에서 객체를 건드리다 보면 객체가 손상될 가능성이 높다.   
은닉은 이러한 손상을 방지할 수 있다.    

**Polymorphism**    
1. 부모 타입에 자식 객체 대입 가능
2. 인터페이스에 구현 객체 대입 가능

---

**static**    
정적 필드와 메소드는 클래스에 고정된 멤버다.   
그렇기 때문에 별도로 객체를 만들지 않아도,    
클래스가 로딩 되었다면 사용할 수 있다.    

**Inheritance & Polymorphism**     
부모 타입의 변수에 자식 객체를 대입할 수 있다.   
이 때 자식 객체는 부모 타입으로 자동 형변환이 된다.    
해당 변수로 메소드를 호출하면 자식 객체가 구현한,   
즉 오버라이딩 된 메소드가 실행된다.    
상황을 요약해보면, 부모 타입이면서 자식 객체를 담고 있는 상황이다.   
이 변수는 거꾸로 자식 객체로 바꾸는 것도 있다.   

~~~
Parent parent = new Child(); // 다형성
if(parent instanceof Child) { // 자식 타입이 부모 타입으로 변환되어 있니?
  Child child = (Child) parent; // 그렇다면 자식 타입으로 형변환
}
~~~


**Interface**   
인터페이스의 이용   
~~~
RemoteControl rc; // 인터페이스 변수 선언

rc = new Television();
rc.turnOn(); // 고품격 음악 토크쇼. 들리는 TV, 라디오 스타~

rc = new Radio();
rc.turnOn(); // 윤하의 별이 빛나는 밤에♪
~~~

---

## CLI
**패키지 컴파일**   
~~~
javac -d 경로 파일
javac -d . ClassName.java // 현재 위치에 패키지 생성
javac -d . com.kakaru.App.java // 현재 위치에 com.kakaru 패키지 생성
                               // App.java 컴파일

~~~

**패키지 실행**    
~~~
java com.kakaru.App // 패키지 최상위 폴더에서만 실행 가능
~~~


---

## 더 알아볼 것
- heap & static
